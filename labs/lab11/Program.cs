using System;
using System.Collections.Generic;

/* Лабораторная работа 11. Интерфейсы и параметризированные коллекции */

namespace lab11
{
    class Program
    {
        static void Main(string[] args)
        {
            /* Выполнить задания лабораторной работы 9, используя для хранения экземпляров
             * разработанных классов стандартные параметризованные коллекции. Во всех классах
             * реализовать интерфейс IComparable и перегрузить операции отношения для  
             * реализации значимой семантики сравнения объектов по какому-либо полю на 
             * усмотрение студента.
             */


            /* Задача 6. 
             * 1. Описать  базовый  класс  Элемент. Закрытые  поля: имя  элемента  (строка  
             * символов); количество  входов  элемента; количество  выходов  элемента. 
             * Методы: конструктор  класса  без  параметров; конструктор,  задающий  имя  и 
             * устанавливающий  равным  1  количество входов  и  выходов; конструктор,  задающий  
             * значения  всех  полей  элемента. Свойства: имя  элемента  (только  чтение); 
             * количество  входов  элемента; количество  выходов  элемента. 
             * 2. На  основе  класса  Элемент  описать  производный  класс  Комбинационный,  
             * представляющий  собой  комбинационный  элемент  (двоичный  вентиль),  который  
             * может  иметь  несколько  входов  и  один  выход. Поле — массив  значений  входов. 
             * Методы: конструкторы; метод,  задающий  значение  на  входах  экземпляра  класса; 
             * метод,  позволяющий  опрашивать  состояние  отдельного  входа  экземпляра класса; 
             * метод,  вычисляющий  значение  выхода  (по  варианту  задания). 
             * 3. На  основе  класса  Элемент  описать  производный  класс  Память, представляющий
             * собой  триггер.  Триггер  имеет  входы,  соответствующие  типу  триггера 
             * (см.  далее  вариант  задания),  и  входы  установки  и  сброса.  Все  триггеры  
             * считаются  синхронными,  сам  синхровход  в  состав  триггера  не  включается. 
             * Поля: массив  значений  входов  объекта  класса,  в  массиве  учитываются  все  
             * входы (управляющие  и  информационные); состояние  на  прямом  выходе  триггера; 
             * состояние  на  инверсном  выходе  триггера. Методы: конструктор  (по  умолчанию сбрасывает
             * экземпляр  класса); конструктор  копирования; метод,  задающий  значение  на 
             * входах  экземпляра  класса; методы,  позволяющие  опрашивать  состояния 
             * отдельного  входа  экземпляра  класса; метод,  вычисляющий  состояние  экземпляра 
             * класса  (по  варианту  задания) в  зависимости  от  текущего  состояния  и 
             * значений  на  входах; метод,  переопределяющий  операцию  == для  экземпляров 
             * класса. 4. 	Создать  класс  Регистр,  используя  класс  Память  как  вложенный 
             * класс. Поля: состояние  входа  «Сброс»  — один  для  экземпляра  класса; состояние  
             * входа  «Установка»  — один  для  экземпляра  класса; массив  типа  Память  
             * заданной  в  варианте  размерности; массив  (массивы),  содержащий  значения  на  
             * соответствующих  входах  элементов  массива  типа  Память. Методы: метод, задающий
             * значение на входах экземпляра  класса; метод, позволяющий опрашивать состояние  
             * отдельного  выхода  экземпляра  класса; О  метод,  вычисляющий  значение  нового  
             * состояния  экземпляра  класса. Все  поля  классов  Элемент,  Комбинационный  и  
             * Память  должны  быть  описаны  с  ключевым  словом  pri  vate. В  задании  
             * перечислены  только  обязательные  члены  и  методы  класса.  Можно задавать  
             * дополнительные  члены  и  методы,  если  они  не  отменяют  обязательные  и  
             * обеспечивают  дополнительные  удобства  при  работе  с  данными  классами, 
             * например,  описать  функции  вычисления  выхода/состояния  как  виртуальные. 
             * 5. 	Для  проверки  функционирования  созданных  классов  написать  программу,
             * использующую  эти  классы.  В  программе  должны  быть  продемонстрированы все  
             * свойства  созданных  классов. Конкретный  тип  комбинационного  элемента,  тип  
             * триггера  и  разрядность  регистра  выбираются  в  соответствии  с  вариантом  
             * задания: Вариант 5, Комбинационный элемент ИЛИ-НЕ, Число входов 8, Триггер V, 
             * Разрядность регистра 9.
            */
            try
            {
                // Тестируем элементы класса Элемент и его потомков
                List<Элемент> elems = new List<Элемент>();
                elems.Add(new Элемент("Элемент1"));
                elems.Add(new Элемент("Элемент2", 2, 2));
                elems.Add(new Комбинационный("Элемент3 - Комбинационный",
                    new byte[] { 0, 0, 1, 0, 1, 1, 1, 0 }));
                elems.Add(new Комбинационный());
                Console.WriteLine($"Состояние элемента {elems[2].Name}: " + elems[2].GetOutputValue());
                byte inp2 = elems[2].GetInputValue(3);
                Console.WriteLine($"На третьм входе Элемента 3 значение {inp2}");
                elems[2].SetInputs(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
                Console.WriteLine("Новое состояние третьего элемента: " + elems[2].GetOutputValue());
                Console.WriteLine("Состояние четвертого элемента по умолчанию: " + elems[3].GetOutputValue());

                // Тестируем класс Регистр и Память
                Регистр regis = new Регистр();
                regis.SetInputs(new byte[,] { { 1, 1}, { 1, 0 }, { 0, 1 }, { 0, 0 },
                    { 1, 1 }, { 1, 0 }, { 0, 1 }, { 1, 1 }, { 0, 0 } });
                Console.WriteLine(regis.GetOutputValue());
                Регистр.Память trigger = regis.memory[0];
                for (int i = 0; i < regis.memory.Length; ++i)
                {
                    string res = "";
                    if (trigger == regis.memory[i])
                    {
                        res += $" {i + 1}";
                    }
                    if (res != "")
                    {
                        Console.WriteLine("Найдены совпадающие с первым триггеры. Их номера:" + res);
                    }

                    
                }
                regis.SetInputs(new byte[,] { { 1, 0}, { 1, 1 }, { 0, 1 }, { 1, 1 },
                    { 0, 1 }, { 0, 1 }, { 1, 1 }, { 1, 1 }, { 0, 1 } });
                string res = regis.GetOutputValue(); // ожидается последовательность 1 0 0 1 1 1 1 0 0
                Console.WriteLine(res); // ожидается последовательность 1 0 0 1 1 1 1 0 0

                Регистр regis2 = new Регистр("Второй регистр", new byte[,](res));
                if(regis2 >= regis)
                {
                    Console.WriteLine(regis2.Name + "Больше" + regis.Name);
                }
                // поместим экзмепляры памяти в параметризированную коллекцию List
                List<Регистр.Память> mem = new List<Регистр.Память>(regis.memory);


                int a = 0;
            }
            catch (Exception e)
            {
                Console.WriteLine("Возникла ошибка: " + e.Message);
            }
        }
    }
}
